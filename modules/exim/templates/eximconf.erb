##
## THIS FILE IS UNDER PUPPET CONTROL. DON'T EDIT IT HERE.
## USE: git clone git+ssh://$USER@puppet.debian.org/srv/puppet.debian.org/git/dsa-puppet.git
##

# This is the main exim4 configuration file based on the 28.08.05 version by
# ametzler

# The configuration file uses a set of rules to generate an
# acceptable mail environment for debian.org machines. It deviates
# considerably from what could be considered a standard exim configuration.

# This configuration file brings in the necessary information from
# other databases stored in /etc/exim/ and the files distributed by ud-ldap

# This file is independent of the local host, it should not be changed
# per machine. primary_hostname is used in all places that require per-host 
# settings.

# The configuration files in /etc/exim are as follows:
#  locals - This is a list of domains that are considered local. A local
#           domain is essential one that deliveries to /var/mail
#           will be attempted. The users available for local delivery
#           comes from /etc/passwd and /etc/aliases. Wildcards are not
#           permitted.
#  virtualdomains - This is a list of all virtual domains. A virtual domain
#           is much like a local domain, execpt that the delivery location
#           and allowed set of users is controlled by a virtual domain
#           alias file and not /etc/passwd. Wildcards are permitted
#  relayhosts - Hostnames that can send any arbitarily addressed mail to
#           us. This is primarily only usefull for emergancy 'queue
#           flushing' operations, but should be populated with a list
#           of trusted machines. Wildcards are not permitted
#  bsmtp_domains - Domains that we deliver locally via bsmtp
<%- if @is_mailrelay -%>
#  mailhubdomains - Domains for which we are the MX, but the mail is relayed
#           elsewhere.  This is designed for use with small volume or
#           restricted machines that need to use a smarthost for mail
#           traffic.  We will relay for them based on ssl cert validation
#           but we need to teach exim how to route the mail to them.  This is
#           that list.
<%- end -%>

# Exim's wildcard mechanism is a bit odd in that to say "any address in
# debian.org including debian.org" you must use two patterns,
#   *.debian.org
#   debian.org
# Also you can only place a * before a . and as the first char in a string.
# Wildcards always match last so they may be used as a catchall.

# Further details can be found in each of the files.

# Usefull exim commands:
#  exim4 -qf  - Try sending all messages right now, including frozen ones
#  exim4 -bt foo@blah - Write what exim would do if it saw the address
#                      Great for testing virtual domains and forward files

# Special Features for users:
# .forward-foo - is understood as an extension address for bar-foo@cow.com
# .forward-default - is understood to be a catch all for bar-*@cow.com
# .procmailrc - with no .forward file invokes procmail for delivery
#               automatically.

# For virtual domains the first lookup is done against a linear text
# database called 'aliases', then .forward files are consulted. Exim
# filtering is available for these .forward files only. .forward-default
# is the universal catch all for everything not handled.

# Heuristic check (none bad enough to cause a hard reject, but in aggregate
# will trigger things like rcpt to rate limiting or possibly a reject if
# enough hits are triggered.
#
# value is stored in acl_c_scr

######################################################################
#                    MAIN CONFIGURATION SETTINGS                     #
######################################################################

<%- if scope.lookupvar('site::nodeinfo').has_key?('heavy_exim') and scope.lookupvar('site::nodeinfo')['heavy_exim'] -%>
perl_startup = do '/etc/exim4/exim_surbl.pl'
<%- end -%>

# These options specify the Access Control Lists (ACLs) that
# are used for incoming SMTP messages - after the RCPT and DATA
# commands, respectively.

acl_smtp_helo = check_helo
acl_smtp_rcpt = ${if ={$interface_port}{587} {check_submission}{check_recipient}}
acl_smtp_data = check_message
<%- if scope.lookupvar('site::nodeinfo').has_key?('heavy_exim') and scope.lookupvar('site::nodeinfo')['heavy_exim'] -%>
acl_smtp_mime = acl_check_mime
<%- end -%>
acl_smtp_predata = acl_check_predata

# accept domain literal syntax in e-mail addresses. To actually make use of
# this a router is also required
allow_domain_literals = true

# This setting defines a named domain list called
# local_domains. It will be referenced
# later on by the syntax "+local_domains".
# Other domain and host lists may follow.
# @ is the local FQDN, @[] matches the IP adress of any local interface.

domainlist local_domains = @ : \
    @[] : \
    localhost : \
    ${if exists {/etc/exim4/locals}{lsearch;/etc/exim4/locals}}

domainlist virtual_domains = partial-lsearch;/etc/exim4/virtualdomains

domainlist submission_domains = ${if exists {/etc/exim4/submission-domains}{/etc/exim4/submission-domains}{}}

domainlist bsmtp_domains = ${if exists {/etc/exim4/bsmtp}{partial-lsearch;/etc/exim4/bsmtp}{}}

domainlist handled_domains = +local_domains : +virtual_domains : +bsmtp_domains

domainlist ourself_and_handled = $primary_hostname : +handled_domains

localpartlist local_only_users = lsearch;/etc/exim4/localusers

localpartlist postmasterish = postmaster : abuse : hostmaster

hostlist debianhosts = <; ; 127.0.0.1 ; ::1 ; /var/lib/misc/thishost/debianhosts ; 89.16.166.49 ; 82.195.75.76 ; 2001:41b8:202:deb:bab5:0:52c3:4b4c

hostlist reservedaddrs = 0.0.0.0/8 : 127.0.0.0/8 : 10.0.0.0/8 : 169.254.0.0/16 : 172.16.0.0/12 : 192.0.0.0/24 : 192.168.0.0/16 : 224.0.0.0/4 : 240.0.0.0/5 : 248.0.0.0/5

<%- if @is_mailrelay -%>
# Domains we relay for; that is domains that aren't considered local but we 
# accept mail for them.
domainlist mailhubdomains = lsearch;/etc/exim4/manualroute

<%- end -%>
tls_certificate = /etc/exim4/ssl/thishost.crt
tls_privatekey = /etc/exim4/ssl/thishost.key
tls_try_verify_hosts = *
tls_verify_certificates = /etc/exim4/ssl/ca.crt
tls_crl = /etc/exim4/ssl/ca.crl

# The setting below causes Exim to do a reverse DNS lookup on all incoming
# IP calls, in order to get the true host name. If you feel this is too
# expensive, you can specify the networks for which a lookup is done, or
# remove the setting entirely.
host_lookup = *
# dns_ipv4_lookup = !localhost (disabled upon sgrans request, zobel, 2010-03-16)

# If this option is set, then any process that is running as one of the
# listed users may pass a message to Exim and specify the sender's
# address using the "-f" command line option, without Exim's adding a
# "Sender" header.

untrusted_set_sender = *

# Some operating systems use the "gecos" field in the system password file
# to hold other information in addition to users' real names. Exim looks up
# this field when it is creating "sender" and "from" headers. If these options
# are set, exim uses "gecos_pattern" to parse the gecos field, and then
# expands "gecos_name" as the user's name. $1 etc refer to sub-fields matched
# by the pattern.

gecos_pattern = ^([^,:]*)
gecos_name = $1

# This tells exim to immediately discard error messages (ie double bounces).
ignore_bounce_errors_after = 0s
auto_thaw = 1d
timeout_frozen_after=14d

message_size_limit = 100M
message_logs = false
smtp_accept_max_per_host = ${if match_ip {$sender_host_address}{+debianhosts}{0}{7}}
<%- if scope.lookupvar('site::nodeinfo').has_key?('heavy_exim') and scope.lookupvar('site::nodeinfo')['heavy_exim'] -%>
smtp_accept_max = 300
smtp_accept_queue = 200
smtp_accept_queue_per_connection = 50
smtp_accept_reserve = 25
<%- else -%>
smtp_accept_max = 30
smtp_accept_queue = 20
smtp_accept_queue_per_connection = 10
smtp_accept_reserve = 5
<%- end -%>
smtp_reserve_hosts = +debianhosts

split_spool_directory = true
check_spool_inodes = 200
check_spool_space  = 20M

delay_warning =

<%- if scope.lookupvar('site::nodeinfo').has_key?('heavy_exim') and scope.lookupvar('site::nodeinfo')['heavy_exim'] -%>
message_body_visible = 5000
queue_run_max = 50
deliver_queue_load_max = 50
queue_only_load = 35
smtp_load_reserve = 20
<%- else -%>
queue_run_max = 5
<%- if scope.lookupvar('::processorcount').to_s != 'undefined' -%>
deliver_queue_load_max = <%= [scope.lookupvar('::processorcount').to_i,2].max * 5 %>
queue_only_load = <%= [scope.lookupvar('::processorcount').to_i,2].max * 4 %>
<%- else -%>
deliver_queue_load_max = 10
queue_only_load = 8
<%- end -%>
<%- end -%>
queue_list_requires_admin = false

<%- if has_variable?("clamd") && clamd == "true" -%>
av_scanner = clamd:/var/run/clamav/clamd.ctl
<%- end -%>

<%= 
ports = []
out = "daemon_smtp_ports = "
ports << 25

if @is_bugsmaster or @is_bugsmx
  ports << 587
end

if not scope.lookupvar('site::nodeinfo')['mail_port'].to_s.empty?
  ports << scope.lookupvar('site::nodeinfo')['mail_port']
end

if @is_mailrelay
  ports << scope.lookupvar('site::nodeinfo')['smarthost_port']
end

out += ports.uniq.sort.join(" : ")
out
%>

admin_groups = adm
remote_sort_domains = *.debian.org:*.debian.net

pipelining_advertise_hosts = !*
tls_advertise_hosts = *
smtp_enforce_sync = true

log_selector = +tls_cipher +tls_peerdn +queue_time +deliver_time +smtp_connection +smtp_incomplete_transaction +smtp_confirmation

received_header_text = Received: ${if def:sender_rcvhost {from $sender_rcvhost\n\t}\
                                 {${if def:sender_ident {from ${quote_local_part:$sender_ident} }}${if def:sender_helo_name {(helo=$sender_helo_name)\n\t}}}}\
                                 ${if and {{eq {$tls_certificate_verified}{1}}{def:tls_peerdn}}{from $tls_peerdn (verified)\n\t}}\
                                 by $primary_hostname ${if def:received_protocol {with $received_protocol}} ${if def:tls_cipher {($tls_cipher)\n\t}}\
                                 (Exim $version_number)\n\t\
                                 ${if def:sender_address {(envelope-from <$sender_address>)\n\t}}\
                                 id $message_exim_id${if def:received_for {\n\tfor $received_for}}

# macro definitions.
# Do not wrap!
VDOMAINDATA = ${lookup{$domain}partial-lsearch{/etc/exim4/virtualdomains}{$value}}
VSENDERDOMAINDATA = ${lookup{$sender_address_domain}partial-lsearch{/etc/exim4/virtualdomains}{$value}}
WHITELIST = ${if match_domain{$domain}{+virtual_domains}\
            {${if exists {${extract{directory}{VDOMAINDATA}{${value}/whitelist}}}\
            {${lookup{$local_part}lsearch{${extract{directory}{VDOMAINDATA}{${value}/whitelist}}}{$value}{}}}{}}}\
            {/etc/exim4/whitelist} } : \
            ${lookup{$local_part}lsearch{/var/lib/misc/$primary_hostname/mail-whitelist}{$value}{}}
GREYLIST_LOCAL_PARTS = ${if match_domain{$domain}{+virtual_domains}\
                       {${if exists {${extract{directory}{VDOMAINDATA}{${value}/grey_users}}}\
                       {${lookup{$local_part}lsearch*{${extract{directory}{VDOMAINDATA}{${value}/grey_users}}}{$local_part}{}}}{}}}\
                       {${lookup{$local_part}lsearch{/etc/exim4/grey_users}{$local_part}{}}}} : \
                       ${lookup{$local_part}lsearch{/var/lib/misc/$primary_hostname/mail-greylist}{$local_part}{}}
RT_QUEUE_MAP = /srv/rt.debian.org/mail/rt_queue_map

######################################################################
#                        ACL CONFIGURATION                           #
######################################################################
begin acl

acl_spamlovers:
  # There are a few profiles that don't want much smtp time checking of
  # mail.  It's easier to track them in one place

  accept  condition      = ${if eq {$acl_m_prf}{PopconMail}}
  accept  condition      = ${if eq {$acl_m_prf}{BugsMail}}
  deny

acl_getprofile:
  # This is a bad hack to reset the variable, by defining it be something
  # never referenced.

  warn    set acl_m_rprf = $acl_m_undefined

  warn    recipients     = survey@popcon.debian.org
          set acl_m_rprf = PopconMail

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    local_parts    = +local_only_users
          domains        = +local_domains
          hosts          = !+debianhosts
          set acl_m_rprf = localonly

<%- if @is_mailrelay -%>
  warn    local_parts    = +local_only_users
          domains        = +mailhubdomains
          hosts          = !+debianhosts
          set acl_m_rprf = localonly

<%- end -%>
  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

<%- if @is_rtmaster -%>
  warn    domains        = rt.debian.org
          set acl_m_rprf = RTMail

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

<%- end -%>
<%- if @is_bugsmaster or @is_bugsmx -%>
  warn    domains        = bugs.debian.org
          set acl_m_rprf = BugsMail

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

<%- end -%>
<%- if @is_packagesmaster -%>
  warn    domains        = packages.debian.org
          set acl_m_rprf = PackagesMail

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

<%- end -%>
<%- if @is_packagesqamaster -%>
  warn    recipients     = owner@packages.qa.debian.org : postmaster@packages.qa.debian.org
          set acl_m_rprf = PTSOwner

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    senders        = :
          domains        = packages.qa.debian.org
          condition      = ${if match{$local_part}{\N^bounces+\N}}
          set acl_m_rprf = PTSListBounce

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    domains        = packages.qa.debian.org
          set acl_m_rprf = PTSMail

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

<%- end -%>
  warn    recipients     = change@db.debian.org : changes@db.debian.org : chpasswd@db.debian.org : ping@db.debian.org : recommend@nm.debian.org
          set acl_m_rprf = DBSignedMail

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    domains        = +virtual_domains
          condition      = ${if exists {${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction}}}}
          condition      = ${if eq{${lookup{$local_part}lsearch*{${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction}}}{$value}{}}}{markup}}
          set acl_m_rprf = markup

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    domains        = +virtual_domains
          condition      = ${if exists {${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction}}}}
          condition      = ${if eq{${lookup{$local_part}lsearch*{${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction}}}{$value}{}}}{blackhole}}
          set acl_m_rprf = blackhole

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    domains        = +virtual_domains
          condition      = ${if exists {${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction.cdb}}}}
          condition      = ${if eq{${lookup{$local_part}cdb{${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction.cdb}}}{$value}{}}}{markup}}
          set acl_m_rprf = markup

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    domains        = +virtual_domains
          condition      = ${if exists {${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction.cdb}}}}
          condition      = ${if eq{${lookup{$local_part}cdb{${extract{directory}{VDOMAINDATA}{${value}/contentinspectionaction.cdb}}}{$value}{}}}{blackhole}}
          set acl_m_rprf = blackhole

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    domains        = +local_domains
          condition      = ${if eq{${lookup{$local_part}cdb{/var/lib/misc/${primary_hostname}/mail-contentinspectionaction.cdb}{$value}{}}}{markup}}
          set acl_m_rprf = markup

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    domains        = +local_domains
          condition      = ${if eq{${lookup{$local_part}cdb{/var/lib/misc/${primary_hostname}/mail-contentinspectionaction.cdb}{$value}{}}}{blackhole}}
          set acl_m_rprf = blackhole

  accept  condition      = ${if eq {$acl_m_rprf}{}{no}{yes}}

  warn    set acl_m_rprf = normal

  accept

check_helo:

  warn    set acl_c_scr    = 0

<%- if @is_mailrelay -%>
  accept  verify   = certificate

<%- end -%>
<%- if scope.lookupvar('site::nodeinfo')['smarthost'].empty? -%>
  # These are in HELO acl so that they are only run once.  They increment a counter,
  # so we don't want it to increment per rcpt to.

  warn    dnslists       = list.dnswl.org&0.0.0.3
          log_message    = Hit on list.dnswl.org for $sender_host_address
          set acl_c_scr  = ${eval:$acl_c_scr-30}

  warn    dnslists       = list.dnswl.org&0.0.0.2
          log_message    = Hit on list.dnswl.org for $sender_host_address
          set acl_c_scr  = ${eval:$acl_c_scr-20}

  warn    dnslists       = list.dnswl.org
          log_message    = Hit on list.dnswl.org for $sender_host_address
          set acl_c_scr  = ${eval:$acl_c_scr-10}

  warn    condition      = ${if isip {$sender_helo_name}{true}{false}}
          log_message    = remote host used IP address in HELO/EHLO greeting
          set acl_c_scr  = ${eval:$acl_c_scr+20}

  warn    !hosts         = +debianhosts
          condition      = ${if eq{$host_lookup_failed}{1}}
          set acl_c_scr  = ${eval:$acl_c_scr+20}

  warn    !hosts         = +debianhosts
          condition      = ${if eq{$host_lookup_failed}{0}}
          condition      = ${if match{$sender_host_name}{\N(^[^\.]*[0-9]\-+[0-9]|^[^\.]*[0-9]{5,}[^\.]|^([^\.]+\.)?[0-9][^ \.]*\.[^\.]+\..+\.[a-z]|^[^\.]*[0-9]\.[^\.]*[0-9]-[0-9]|^(dyn|cable|dhcp|dialup|ppp|adsl)[^\.]*[0-9])\N}}
          set acl_c_scr  = ${eval:$acl_c_scr+20}

  warn    !hosts         = +debianhosts
          condition      = ${if match{$sender_helo_name}{\N(^[^\.]*[0-9]\-+[0-9]|^[^\.]*[0-9]{5,}[^\.]|^([^\.]+\.)?[0-9][^ \.]*\.[^\.]+\..+\.[a-z]|^[^\.]*[0-9]\.[^\.]*[0-9]-[0-9]|^(dyn|cable|dhcp|dialup|ppp|adsl)[^\.]*[0-9])\N}}
          set acl_c_scr  = ${eval:$acl_c_scr+20}

  warn    !hosts         = +debianhosts
          dnslists       = dul.dnsbl.sorbs.net
          set acl_c_scr  = ${eval:$acl_c_scr+15}

  # If the sender's helo name is empty, the message will be rejected later
  # because the helo is empty.  If the rDNS lookup failed, we are already
  # going to greylist them, so no sense worrying about it here.  Finally,
  # if rDNS does not match helo name (both lower cased first), greylist.

  warn    !hosts         = +debianhosts
          condition      = ${if eq {$host_lookup_failed}{1}{no}{yes}}
          condition      = ${if def:sender_helo_name {yes}{no}}
          condition      = ${if eq {${lc:$sender_helo_name}}{${lc:$sender_host_name}}{no}{yes}}
          log_message    = HELO doesn't match rDNS
          set acl_c_scr  = ${eval:$acl_c_scr+8}

  # Regexes of doom
  # matches 098325879 - looks fishy

  warn condition        = ${if and { \
                                     { !match{$sender_helo_name}{\N^\[.+\]$\N} } \
                                     { !match{$sender_helo_name}{\N^(?i)((?=[^-])[a-z0-9-]*[a-z0-9]\.)+[a-z]{2,6}$\N} } \
                                    } \
                            }
       log_message      = non-FQDN HELO
       set acl_c_scr    = ${eval:$acl_c_scr+12}

  # Matches DOMAIN99.com - looks bad

  warn condition       = ${if match {$sender_helo_name}{\N^[A-Z]+[A-Z0-9\-]+\.[A-Za-z0-9]+$\N}}
       log_message     = SHOUTING HELO
       set acl_c_scr   = ${eval:$acl_c_scr+7}

  # Random HELO (run of 7 consonants) (constructed by viruses).  We purposefully
  # skip matching on machines named .*smtp.*, since that's 4 already.  This is a fairly
  # naive test, so it's not worth much

  warn condition       = ${if match {${lc:$sender_helo_name}}{smtp}{no}{yes}}
       condition       = ${if match {${lc:$sender_helo_name}}{\N^[a-z0-9]+\.[a-z]+$\N}}
       condition       = ${if match {${lc:$sender_helo_name}}{\N.*[bcdfghjklmnpqrstvwxz]{7,}.*\.[a-z]+$\N}}
       log_message     = random HELO
       set acl_c_scr   = ${eval:$acl_c_scr+5}

<%- else -%>
  drop !hosts          = +debianhosts
       log_message     = mail from non-d.o host
       message         = Interesting.  I doubt that should have happened.

<%- end -%>
  # Implicit, but simpler to just say it
  accept

#!!# ACL that is used after the RCPT command on the submission port
check_submission:

  # Accept if the source is local SMTP (i.e. not over TCP/IP).
  # We do this by testing for an empty sending host field.
  accept  hosts = +debianhosts

<%- if @is_mailrelay -%>
  accept  verify   = certificate

<%- end -%>
  # Defer after too many bad RCPT TO's.  Legit MTAs will retry later.
  # This is a rough pass at preventing addres harvesting or other mail blasts.

  defer  log_message   = Too many bad recipients ${eval:$rcpt_fail_count} out of $rcpt_count
         message       = Too many bad recipients, try again later
         condition     = ${if > {${eval:$rcpt_fail_count}}{3}{yes}{no}}

  defer
          ratelimit      = 5 / 60m / per_rcpt / $sender_host_address
          !hosts         = +debianhosts
          message        = sorry, only 5 reports per hour for submission

  accept  domains  = +local_domains
          hosts    = +debianhosts
          endpass
	  verify   = recipient

<%- if @is_mailrelay -%>
  accept  domains  = +mailhubdomains
          endpass
	  verify   = recipient/callout=30s,defer_ok,use_sender,no_cache

<%- end -%>
  accept  domains  = +submission_domains
          endpass
	  verify   = recipient

  deny    message = relay not permitted

#!!# ACL that is used after the RCPT command
check_recipient:

<%- if @is_mailrelay -%>
  accept  verify   = certificate

<%- end -%>
  accept  hosts = <; ::1 ; 127.0.0.1 ; @
  warn    acl           = acl_getprofile
          condition     = ${if eq{$acl_m_prf}{}}
          set acl_m_prf = $acl_m_rprf

  defer   condition     = ${if eq{$acl_m_prf}{$acl_m_rprf}{no}{yes}}
          message       = Different profile, please retry
          log_message   = Only one profile at a time, please

  # Defer after too many bad RCPT TO's.  Legit MTAs will retry later.
  # This is a rough pass at preventing address harvesting or other mail blasts.

  defer  log_message   = Too many bad recipients ${eval:$rcpt_fail_count} out of $rcpt_count
         !acl          = acl_spamlovers
         message       = Too many bad recipients, try again later
         !hosts        = +debianhosts
         condition     = ${if > {${eval:$rcpt_fail_count}}{3}{yes}{no}}

  # Dump spambots that are so stupid they say helo as our IP address

  drop   !hosts        = +debianhosts
         !acl          = acl_spamlovers
         condition     = ${if eq {$sender_helo_name}{$interface_address}{yes}{no}}
         message       = HELO mismatch Forged HELO for ($sender_helo_name)

  # Also for spambots that say helo as us or one of our domains

  drop   !hosts        = +debianhosts
         !acl          = acl_spamlovers
         condition     = ${if match_domain{$sender_helo_name}{+ourself_and_handled}}
         condition     = ${if !match{$sender_host_name}{${rxquote:$sender_helo_name}\N$\N}}
         message       = HELO mismatch Forged HELO for ($sender_helo_name)

  # This logic gives you a list of commonly forged domains in helo to reject against

  warn set acl_m_frg   = ${lookup{$sender_helo_name} \
                           nwildlsearch{/etc/exim4/helo-check} \
                          {${if eq{$value}{}{$sender_helo_name}{$value}}}{}}

  # This is a failsafe in case DNS fails - we defer instead of hard reject if they 
  # say helo as a name in the list but we can't look them up

  defer  !hosts        = +debianhosts
         !acl          = acl_spamlovers
         condition     = ${if eq{$acl_m_frg}{}{no}{yes}}
         condition     = ${if eq{$sender_host_name}{}{yes}{no}}
         condition     = ${if eq{$host_lookup_failed}{1}{no}{yes}}
         message       = Access temporarily denied. Resolve failed PTR for $sender_host_address

  # If DNS works, go ahead and reject them

  drop   !hosts        = +debianhosts
         !acl          = acl_spamlovers
         condition     = ${if and { {!eq{$acl_m_frg}{}}{!match{$sender_host_name}{${rxquote:$acl_m_frg}\N$\N}}}{yes}{no}}
         message       = HELO mismatch Forged HELO for ($sender_helo_name)

  # disabled accounts don't even get local mail.
  deny   domains       = +virtual_domains
         local_parts   = ${if exists {${extract{directory}{VDOMAINDATA}{${value}/mail-disable}}}\
                                     {lsearch;${extract{directory}{VDOMAINDATA}{${value}/mail-disable}}}\
                                     {}}
         message       = ${lookup{$local_part}lsearch{${extract{directory}{VDOMAINDATA}{${value}/mail-disable}}}{$value}}

  deny   local_parts   = lsearch;/var/lib/misc/$primary_hostname/mail-disable
         domains       = +local_domains
	 message       = ${lookup{$local_part}lsearch{/var/lib/misc/$primary_hostname/mail-disable}{$value}}

  deny   domains       = +virtual_domains
         local_parts   = ${if exists {${extract{directory}{VDOMAINDATA}{${value}/localonly}}}\
                                     {${extract{directory}{VDOMAINDATA}{${value}/localonly}}}\
                                     {}}
         hosts         = !+debianhosts
         message       = mail for <$local_part@$domain> only accepted from debian.org machines

  # Accept if the source is local SMTP (i.e. not over TCP/IP).
  # We do this by testing for an empty sending host field.
  accept  hosts = :
  
  deny    domains       = +handled_domains
          local_parts   = ^[.] : ^.*[@%!/|]
  
  deny    domains       = !+handled_domains
          local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./

# forwards mail to @d.o address, even if it's a bounce from master, no reply
# from source address; rejecting all mail now.
  deny    recipients    = mendoza@debian.org
          hosts         = 65.110.39.147 : 64.39.31.15
          message       = <mendoza@kenny.linuxsis.net> cannot forward here while mailer-daemon mail is not caught

  deny    condition     = ${lookup{$sender_address_local_part}lsearch{/etc/exim4/localusers}{true}}
	  sender_domains= +local_domains
	  hosts         = !+debianhosts
	  message       = mail from <$sender_address> not allowed externally

  deny    sender_domains= +virtual_domains
          condition     = ${if exists {${extract{directory}{VSENDERDOMAINDATA}{${value}/localusers}}}}
          condition     = ${lookup{$sender_address_local_part}lsearch{${extract{directory}{VSENDERDOMAINDATA}{${value}/localusers}}}{true}}
	  hosts         = !+debianhosts
	  message       = mail from <$sender_address> not allowed externally

  deny    condition     = ${if match_domain{$sender_address_domain}{+virtual_domains}{1}{0}}
          condition     = ${if exists {${extract{directory}{VSENDERDOMAINDATA}{${value}/neversenders}}}{1}{0}}
          condition     = ${lookup{$sender_address_local_part}lsearch{${extract{directory}{VSENDERDOMAINDATA}{${value}/neversenders}}{true}}
	  message       = no mail should ever come from <$sender_address>

  warn    condition     = ${if eq{$acl_m_prf}{localonly}}
          set acl_m_lrc = ${if eq{$acl_m_lrc}{}{$local_part@$domain}{$acl_m_lrc, $local_part@$domain}}

<%- if @is_packagesmaster -%>
  warn    condition      = ${if eq {$acl_m_prf}{PackagesMail}}
          condition      = ${if eq {$sender_address}{$local_part@$domain}}
          message        = X-Packages-FromTo-Same: yes

<%- end -%>
  deny    condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
          !verify        = sender

  defer   !hosts         = +debianhosts
          condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
          condition      = ${if >{${eval:$acl_c_scr+0}}{0}}
          ratelimit      = 10 / 60m / per_rcpt / $sender_host_address
          message        = slow down (no reverse dns, mismatched ehlo, dialup, or in blacklists)

<%- if has_variable?("policydweight") && policydweight == "true" -%>
  # Check with policyd-weight - this only works with a version after etch's,
  # sadly.  etch's version attempts to hold the socket open, since that's what
  # postfix expects.  Exim, on the other hand, expects the remote side to close
  # the socket when it's finished sending data, so it see each transaction as
  # an incomplete read.  I'm sure there's a way we could force exim to do
  # something sick and clever to force either the interpretation or the socket
  # closure, but I'm fairly sure it's now worth it, since the backport of
  # policyd-weight is trivial.
  warn  !hosts         = +debianhosts
        condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
        set acl_m_pw   = ${readsocket{inet:127.0.0.1:12525}\
                          {request=smtpd_access_policy\n\
                           protocol_state=RCPT\n\
                           protocol_name=${uc:$received_protocol}\n\
                           helo_name=$sender_helo_name\n\
                           queue_id=$message_exim_id\n\
                           sender=$sender_address\n\
                           recipient=$local_part@$domain\n\
                           recipient_count=$rcpt_count\n\
                           client_address=$sender_host_address\n\
                           client_name=$sender_host_name\n\
                           reverse_client_name=$sender_host_name\n\
                           instance=$sender_host_address.$sender_address.$sender_helo_name\n\n}\
                          {20s}{\n}{socket failure}}

  # Defer on socket error
  defer !hosts         = +debianhosts
        condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
        condition      = ${if eq{$acl_m_pw}{socket failure}{yes}{no}}
        message        = Cannot connect to policyd-weight. Please try again later.

  # Set proposed action to $acl_m_act and message to $acl_m_mes
  warn  !hosts         = +debianhosts
        condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
        set acl_m_mes  = ${extract{action}{$acl_m_pw}}
        set acl_m_act  = ${sg{$acl_m_pw}{\Naction=[^ ]+ (.*)\n\n\N}{\$1}}

  # Add X-policyd-weight header line to message
  warn  !hosts         = +debianhosts
        condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
        message        = $acl_m_mes
        condition      = ${if eq{$acl_m_act}{PREPEND}{yes}{no}}

  # Write log message, if policyd-weight can't run checks
  warn  !hosts         = +debianhosts
        condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
        log_message    = policyd-weight message: $acl_m_mes
        condition      = ${if eq{$acl_m_act}{DUNNO}{yes}{no}}

  # Deny mails which policyd-weight thinks are spam
  deny  !hosts         = +debianhosts
        condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
        message        = policyd-weight said: $acl_m_mes
        condition      = ${if eq{$acl_m_act}{550}{yes}{no}}

  # Defer messages when policyd-weight suggests so.
  defer  !hosts         = +debianhosts
         condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
         message        = policyd-weight said: $acl_m_mes
         condition      = ${if eq{$acl_m_act}{450}{yes}{no}}

<%- end -%>
<%- if @is_rtmaster -%>
  warn    condition     = ${if eq{$acl_m_prf}{RTMail}}
          set acl_m12   = ${if def:acl_m12 {$acl_m12} {${if or{{match{$local_part}{\N[^+]+\+\d+\N}}{match{$local_part}{\N[^+]+\+new\N}}{match{$local_part}{3520}}{match{$local_part}{3645}}} {RTMailRecipientHasSubaddress}}}}
  # temporary hack because weasel screwed up and gave people an rt-3520@ address, which doesn't really work normally.  and rt-3645
  #set acl_m12  = ${if def:acl_m12 {$acl_m12} {${if or{{match{$local_part}{\N[^+]+\+\d+\N}}{match{$local_part}{\N[^+]+\+new\N}}} {RTMailRecipientHasSubaddress}}}}


<%- end -%>
<%- if has_variable?("greylistd") && greylistd == "true" -%>
  defer
    message  = $sender_host_address is not yet authorized to deliver mail from <$sender_address> to <$local_part@$domain>.
    log_message = greylisted.
    local_parts    = ${if match_domain{$domain}{+virtual_domains}\
		     {${if exists {${extract{directory}{VDOMAINDATA}{${value}/grey_users}}}\
		     {${lookup{$local_part}lsearch*{${extract{directory}{VDOMAINDATA}{${value}/grey_users}}}{$local_part}{}}}{}}}\
		     {${lookup{$local_part}lsearch{/etc/exim4/grey_users}{$local_part}{}} : \
		     ${lookup{$local_part}lsearch{/var/lib/misc/$primary_hostname/mail-greylist}{$local_part}{}}}}
    !senders       = :
    !hosts         = : +debianhosts : WHITELIST : \
                     ${if exists {/etc/greylistd/whitelist-hosts}\
                                 {/etc/greylistd/whitelist-hosts}{}} : \
                     ${if exists {/var/lib/greylistd/whitelist-hosts}\
                                 {/var/lib/greylistd/whitelist-hosts}{}} 
    condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
    !authenticated = *
    domains        = +handled_domains
    condition      = ${readsocket{/var/run/greylistd/socket}\
                                 {--grey \
                                  $sender_host_address \
                                  $sender_address \
                                  $local_part@$domain}\
                                 {5s}{}{false}}

<%- elsif has_variable?("postgrey") && postgrey == "true" -%>
  # next three are greylisting, inspired by http://www.bebt.de/blog/debian/archives/2006/07/30/T06_12_27/index.html
  # this adds acl_m_grey if there isn't one (so unique per message)
  warn
    !senders       = :
    !hosts         = : +debianhosts : WHITELIST
    condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
    condition      = ${if def:acl_m_grey {no}{yes}}
    set acl_m_grey = $pid.$tod_epoch.$sender_host_port

  # and defers the message if postgrey thinks it should be defered ...
  defer
    !senders       = :
    !hosts         = : +debianhosts : WHITELIST
    condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
    !authenticated = *
    domains        = +handled_domains
    local_parts    = GREYLIST_LOCAL_PARTS
    set acl_m_pgr  = request=smtpd_access_policy\n\
                     protocol_state=RCPT\n\
                     protocol_name=${uc:$received_protocol}\n\
                     instance=${acl_m_grey}\n\
                     helo_name=${sender_helo_name}\n\
                     client_address=${substr_-3:${mask:$sender_host_address/24}}\n\
                     client_name=${sender_host_name}\n\
                     sender=${sender_address}\n\
                     recipient=$local_part@$domain\n\n
    set acl_m_pgr  = ${sg{\
                         ${readsocket{/var/run/postgrey/socket}{$acl_m_pgr}\
                               {5s}{}{action=DUNNO}}\
                     }{action=}{}}
    message        = ${sg{$acl_m_pgr}{^\\w+\\s*}{}}
    log_message    = greylisted.
    condition      = ${if eq{${uc:${substr{0}{5}{$acl_m_pgr}}}}{DEFER}}

 # ... or adds a header with information about how long the delay was
 warn
    !senders       = :
    !hosts         = : +debianhosts : WHITELIST
    condition      = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
    !authenticated = *
    domains        = +handled_domains
    local_parts    = GREYLIST_LOCAL_PARTS
    condition      = ${if eq{${uc:${substr_0_7:$acl_m_pgr}}}{PREPEND}}
    message        = ${sg{$acl_m_pgr}{^\\w+\\s*}{}}

<%- end -%>
  accept  local_parts   = +postmasterish
          domains       = +virtual_domains : +bsmtp_domains

  deny    hosts        = ${if exists{/etc/exim4/host_blacklist}{/etc/exim4/host_blacklist}{}}
          message      = I'm terribly sorry, but it seems you have been blacklisted
          log_message  = blacklisted IP

  deny   log_message   = <$sender_address> is blacklisted
         senders       = ${if exists{/etc/exim4/blacklist}{/etc/exim4/blacklist}{}}
         message       = We have blacklisted <$sender_address>.  Please stop mailing us

<%- if scope.lookupvar('site::nodeinfo')['smarthost'].empty? -%>
  deny    message  = host $sender_host_address is listed in $dnslist_domain; see $dnslist_text
          dnslists = ${if match_domain{$domain}{+virtual_domains}\
		     {${if exists {${extract{directory}{VDOMAINDATA}{${value}/rbllist}}}\
		     {${lookup{$local_part}lsearch*{${extract{directory}{VDOMAINDATA}{${value}/rbllist}}}{$value}{}}}{}}}\
		     {${lookup{$local_part}lsearch{/etc/exim4/rbllist}{$value}{}}}} : \
		     ${lookup{$local_part}lsearch{/var/lib/misc/$primary_hostname/mail-rbl}{$value}{}}
	  domains       = +handled_domains
	  !hosts        = +debianhosts : WHITELIST

<%- end -%>
  deny    message  = domain $sender_address_domain is listed in $dnslist_domain; see $dnslist_text
          dnslists = ${if match_domain{$domain}{+virtual_domains}\
		     {${if exists {${extract{directory}{VDOMAINDATA}{${value}/rhsbllist}}}\
		     {${expand:${lookup{$local_part}lsearch*{${extract{directory}{VDOMAINDATA}{${value}/rhsbllist}}}{$value}{}}}}{}}}\
		     {${expand:${lookup{$local_part}lsearch{/etc/exim4/rhsbllist}{$value}{}}}}} : \
		     ${expand:${lookup{$local_part}lsearch{/var/lib/misc/$primary_hostname/mail-rhsbl}{$value}{}}}
	  domains       = +handled_domains
	  !hosts        = +debianhosts : WHITELIST

<%- if scope.lookupvar('site::nodeinfo')['smarthost'].empty? -%>
  deny    domains  = +handled_domains
          local_parts = ${if match_domain{$domain}{+virtual_domains}\
                        {${if exists {${extract{directory}{VDOMAINDATA}{${value}/callout_users}}}\
                        {${lookup{$local_part}lsearch*{${extract{directory}{VDOMAINDATA}{${value}/callout_users}}}{$local_part}{}}}{}}}\
                        {${lookup{$local_part}lsearch{/etc/exim4/callout_users}{$local_part}{}}}} : \
                        ${lookup{$local_part}lsearch{/var/lib/misc/$primary_hostname/mail-callout}{$local_part}{}}
          !hosts   = +debianhosts : WHITELIST
	  !verify  = sender/callout=90s,maxwait=300s
	  message  = "Sender verification failed: $acl_verify_message"

<%- end -%>
<%- if @is_mailrelay -%>
  accept  domains  = +mailhubdomains
          endpass
	  verify   = recipient/callout=30s,defer_ok,use_sender,no_cache

<%- end -%>
  accept  domains  = +handled_domains
          endpass
	  verify   = recipient/defer_ok

  accept  hosts         = +debianhosts

  accept  authenticated = *

  deny    message = relay not permitted

<%- if scope.lookupvar('site::nodeinfo').has_key?('heavy_exim') and scope.lookupvar('site::nodeinfo')['heavy_exim'] -%>
acl_check_mime:

 accept  verify        = certificate
 accept  hosts         = +debianhosts

 discard condition     = ${if <{$message_size}{256000}}
         condition     = ${if eq {$acl_m_prf}{blackhole}}
         set acl_m_srb = ${perl{surblspamcheck}}
         condition     = ${if eq{$acl_m_srb}{false}{no}{yes}}
         log_message   = discarded surbl message for $recipients

  deny   condition     = ${if <{$message_size}{256000}}
         condition     = ${if eq {$acl_m_prf}{markup}{no}{yes}}
         condition     = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
         set acl_m_srb = ${perl{surblspamcheck}}
         condition     = ${if eq{$acl_m_srb}{false}{no}{yes}}
         log_message   = $acl_m_srb
         message       = $acl_m_srb

  warn   condition     = ${if <{$message_size}{256000}}
         condition     = ${if eq {$acl_m_prf}{markup}}
         set acl_m_srb = ${perl{surblspamcheck}}
         condition     = ${if eq{$acl_m_srb}{false}{no}{yes}}
         message       = X-Surbl-Hit: $primary_hostname: $acl_m_srb

  accept

<%- end -%>
acl_check_predata:
  deny   condition     = ${if eq{$acl_m_prf}{localonly}}
         message       = mail for $acl_m_lrc is only accepted internally

  accept


#!!# ACL that is used after the DATA command
check_message:

  # Some people put from hostmaster@something.debian.org in the From
  # header.  Take their crack pipe away.
  drop   condition = ${if match{${lc:$h_From:}}{\Npostmaster@([^.]+\.)?debian\.org\N}}

<%- if @is_rtmaster -%>
  deny    condition = ${if eq {$acl_m_prf}{RTMail}}
          condition = ${if and{{!match {${lc:$rh_Subject:}} {debian rt}} \
                               {!match {${lc:$rh_Subject:]}} {\N\[rt.debian.org \N}} \
                               {!match {$acl_m12}{RTMailRecipientHasSubaddress}}}}
          message  = messages to the Request Tracker system require a subject tag or a subaddress

<%- end -%>
<%- if @is_packagesqamaster -%>
  deny    !hosts  = +debianhosts : 5.153.231.21
          condition = ${if eq {$acl_m_prf}{PTSMail}}
          condition = ${if def:h_X-PTS-Approved:{false}{true}}
          message   = messages to the PTS require an X-PTS-Approved header

<%- end -%>
  deny    condition      = ${if eq {$acl_m_prf}{DBSignedMail}}
          condition      = ${if and {{!match {$message_body}{PGP MESSAGE}}              \
                                     {!match {$message_body}{PGP SIGNED MESSAGE}}       \
                                     {!match {$message_body}{PGP SIGNATURE}}            \
                                     {!match {$header_content-type:}{multipart/signed}} \
                                     {!match {$header_content-type:}{pgp}}              \
                                    }                                                   \
                            }
          message        = Mail to this address needs to be PGP-signed

  accept  verify    = certificate
  accept  hosts     = +debianhosts

  deny    condition = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
          !verify   = header_syntax
          message   = Invalid header syntax: $acl_verify_message

# RFC 822 and 2822 say that headers must be ASCII.  This kinda emulates
# postfix's strict_7bit_headers option, but only checks a few common problem
# headers, as there doesn't appear to be an easy way to check them all.
  deny
  	  condition       = ${if or {{match {$rh_Subject:}{[\200-\377]}}\
	                         {match {$rh_To:}{[\200-\377]}}\
				 {match {$rh_From:}{[\200-\377]}}\
				 {match {$rh_Cc:}{[\200-\377]}}}{true}{false}}
          condition       = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
	  message         = improper use of 8-bit data in message header: message rejected

  deny
  	  condition       = ${if match {$rh_Subject:}{[^[:print:]]\{8\}}{true}{false}}
          condition       = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
	  message         = Your mailer is not RFC 2047 compliant: message rejected

<%- if has_variable?("clamd") && clamd == "true" -%>
  discard condition       = ${if eq {$acl_m_prf}{blackhole}}
          demime          = *
          malware         = */defer_ok
          log_message     = discarded malware message for $recipients

  deny    condition       = ${if eq {$acl_m_prf}{markup}{no}{yes}}
          condition       = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
  	  demime          = *
          malware         = */defer_ok
          message         = malware detected: $malware_name: message rejected

  warn    condition       = ${if eq {$acl_m_prf}{markup}}
  	  demime          = *
          malware         = */defer_ok
          message         = X-malware detected: $malware_name

<%- end -%>
<%- if scope.lookupvar('site::nodeinfo').has_key?('heavy_exim') and scope.lookupvar('site::nodeinfo')['heavy_exim'] -%>
 discard condition     = ${if <{$message_size}{256000}}
         condition     = ${if eq {$acl_m_prf}{blackhole}}
         set acl_m_srb = ${perl{surblspamcheck}}
         condition     = ${if eq{$acl_m_srb}{false}{no}{yes}}
         log_message   = discarded surbl message for $recipients

  deny   condition     = ${if <{$message_size}{256000}}
         condition     = ${if eq {$acl_m_prf}{markup}{no}{yes}}
         condition     = ${if eq {$acl_m_prf}{PopconMail}{no}{yes}}
         set acl_m_srb = ${perl{surblspamcheck}}
         condition     = ${if eq{$acl_m_srb}{false}{no}{yes}}
         log_message   = $acl_m_srb
         message       = $acl_m_srb

  warn   condition     = ${if <{$message_size}{256000}}
         condition     = ${if eq {$acl_m_prf}{markup}}
         set acl_m_srb = ${perl{surblspamcheck}}
         condition     = ${if eq{$acl_m_srb}{false}{no}{yes}}
         message       = X-Surbl-Hit: $primary_hostname: $acl_m_srb

<%- end -%>
  # Check header_sender except for survey@popcon.d.o
  deny    condition    = ${if eq{$acl_m_prf}{PopconMail}{false}{true}}
          !verify      = header_sender
          message      = No valid sender found in the From:, Sender: and Reply-to: headers

<%- if @is_packagesmaster -%>
  deny  message        = Congratulations, you scored $spam_score points.
        log_message    = spam: $spam_score points.
        condition      = ${if eq {$acl_m_prf}{PackagesMail}}
        !authenticated = *
        !verify        = certificate
        !hosts         = +debianhosts
        condition      = ${if <{$message_size}{256000}}
        spam           = pkg_user : true
        condition      = ${if >{$spam_score_int}{59}}

<%- end -%>
  accept



######################################################################
#                      REWRITE CONFIGURATION                         #
######################################################################



begin rewrite

\N^buildd_(.*)@franck\.debian\.org$\N buildd_$1@buildd.debian.org T
*@debian.org ${lookup{$1}cdb{/var/lib/misc/${primary_hostname}/mail-forward.cdb}{$value}fail} T
*@people.debian.org ${lookup{$1}cdb{/var/lib/misc/${primary_hostname}/mail-forward.cdb}{$value}fail} T
#*@${primary_hostname} "${if exists{/etc/exim4/email-addresses}{${lookup{$1}lsearch{/etc/exim4/email-addresses}{$value}fail}}fail}" fFs
m68k@buildd.debian.org m68k-build@nocrew.org Ttrbc


#!!#######################################################!!#
#!!# Here follow routers created from the old routers,   #!!#
#!!# for handling non-local domains.                     #!!#
#!!#######################################################!!#

begin routers



######################################################################
#                      ROUTERS CONFIGURATION                         #
#                Specifies how addresses are handled                 #
######################################################################
#                          ORDER DOES MATTER                         #
#     An address is passed to each in turn until it is accepted.     #
######################################################################

<%- if @is_mailrelay -%>
relay_manualroute:
  driver = manualroute
  domains = +mailhubdomains
  transport = remote_smtp
  route_data = ${lookup{$domain}lsearch{/etc/exim4/manualroute}}
  require_files = /etc/exim4/manualroute

<%- end -%>
bsmtp:
  debug_print = "R: bsmtp for $local_part@$domain"
  driver = manualroute
  domains = +bsmtp_domains
  require_files = /etc/exim4/bsmtp
  route_list = * ${extract{file}{\
                   ${lookup{$domain}partial-lsearch{/etc/exim4/bsmtp}\
		     {$value}fail}}}
  transport = bsmtp

# This router routes to remote hosts over SMTP by explicit IP address,
# given as a "domain literal" in the form [nnn.nnn.nnn.nnn]. The RFCs
# require this facility, which is why it is enabled by default in Exim.
ipliteral:
  debug_print = "R: ipliteral for $local_part@$domain"
  driver = ipliteral
  domains = !+handled_domains
  transport = remote_smtp
  ignore_target_hosts = +reservedaddrs

<%=
out = ""
if not scope.lookupvar('site::nodeinfo')['smarthost'].empty?
out = "
smarthost:
  debug_print = \"R: smarthost for $local_part@$domain\"
  driver = manualroute
  domains = !+handled_domains
  transport = remote_smtp_smarthost
  route_list = * #{scope.lookupvar('site::nodeinfo')['smarthost']}
  host_find_failed = defer
  same_domain_copy_routing = yes
  no_more
"
end
out
%>

# This router routes to remote hosts over SMTP using a DNS lookup.
# Ignore reserved network responses, including localhost.
dnslookup:
  debug_print = "R: dnslookup for $local_part@$domain"
  driver = dnslookup
  domains = !+handled_domains
  transport = remote_smtp
  ignore_target_hosts = +reservedaddrs
  no_more

postmasterish:
  debug_print = "R: postmasterish for $local_part@$domain"
  driver = redirect
  verify = false
  unseen = true
  expn = true
  local_parts = +postmasterish
  domains = +virtual_domains : +bsmtp_domains
  data = debian-admin@debian.org
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"

# This router handles aliasing using a traditional /etc/aliases file.
# If any of your aliases expand to pipes or files, you will need to set
# up a user and a group for these deliveries to run under. You can do
# this by uncommenting the "user" option below (changing the user name
# as appropriate) and adding a "group" option if necessary.

system_aliases:
  debug_print = "R: system_aliases for $local_part@$domain"
  driver = redirect
  allow_defer
  allow_fail
  data = ${lookup{$local_part}lsearch*{/etc/aliases}}
  domains = +local_domains
  file_transport = address_file
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  pipe_transport = address_pipe
  retry_use_local_part

# This router handles forwarding using traditional .forward files.
# It also allows mail filtering when a forward file starts with the 
# string "# Exim filter": to disable filtering, uncomment the "filter" 
# option. The check_ancestor option means that if the forward file 
# generates an address that is an ancestor of the current one, the 
# current one gets passed on instead. This covers the case where A is 
# aliased to B and B has a .forward file pointing to A.

# For standard debian setup of one group per user, it is acceptable---normal
# even---for .forward to be group writable. If you have everyone in one
# group, you should comment out the "modemask" line. Without it, the exim
# default of 022 will apply, which is probably what you want.

userforward_verify:
  debug_print = "R: userforward for $local_part${local_part_suffix}@$domain"
  driver = redirect
  check_ancestor
  user = Debian-exim
  no_check_local_user
  directory_transport = address_directory
  domains = +local_domains
  # filter - I have disabled filtering to force users to use .forward-foo files
  # or procmail. This will make it easier to move mailers in the future
  #
  # This bit does the qmailesque extension names, foo-bar@ is .forward-foo it
  # also checks if the .forward-bar exists, if not then it uses
  # .forward-default instead.
  file = $home/.forward\
         ${if eq{}{$local_part_suffix}{}{\
	   ${if exists {${home}/.forward${local_part_suffix}} \
	     {${local_part_suffix}}{-default}}\
	   }\
	  }
  file_transport = address_file
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  local_part_suffix = -*
  local_part_suffix_optional
  modemask = 002
  pipe_transport = address_pipe
  reply_transport = address_reply
  require_files = $home
  router_home_directory = ${lookup passwd{$local_part}{${extract{5}{:}{$value}}}fail}
  verify_only

# This is a senmailesque alias file lookup
virt_aliases:
  debug_print = "R: virt_aliases for $local_part@$domain"
  driver = redirect
  allow_defer
  allow_fail
  data = ${if exists{\
           ${extract{directory}{VDOMAINDATA}{${value}/aliases}}}\
	   {${lookup{$local_part}lsearch*{\
              ${extract{directory}{VDOMAINDATA}{$value/aliases}}\
	   }}}}
  directory_transport = address_directory
  domains = +virtual_domains
  file_transport = ${if eq {${extract{group_writable}{VDOMAINDATA}}}{true}{address_file_group}{address_file}}
  cannot_route_message = Unknown user
  group = ${extract{group}{VDOMAINDATA}}
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  pipe_transport = address_pipe
  qualify_preserve_domain
  retry_use_local_part
  transport_current_directory = ${extract{directory}{VDOMAINDATA}}
  transport_home_directory = ${extract{directory}{VDOMAINDATA}}
  user = ${extract{user}{VDOMAINDATA}}
  
# No direct match, so try doing a regex match if there's an
# aliases.regex
virt_aliases_regex:
  debug_print = "R: virt_aliases_regex for $local_part$local_part_suffix@$domain"
  driver = redirect
  allow_defer
  allow_fail
  data = ${if exists{\
           ${extract{directory}{VDOMAINDATA}{${value}/aliases.regex}}}\
	   {${lookup{$local_part}nwildlsearch*{\
              ${extract{directory}{VDOMAINDATA}{$value/aliases.regex}}\
	   }}}}
  directory_transport = address_directory
  domains = +virtual_domains
  file_transport = ${if eq {${extract{group_writable}{VDOMAINDATA}}}{true}{address_file_group}{address_file}}
  cannot_route_message = Unknown user
  group = ${extract{group}{VDOMAINDATA}}
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  pipe_transport = address_pipe
  qualify_preserve_domain
  retry_use_local_part
  transport_current_directory = ${extract{directory}{VDOMAINDATA}}
  transport_home_directory = ${extract{directory}{VDOMAINDATA}}
  user = ${extract{user}{VDOMAINDATA}}

userforward:
  debug_print = "R: userforward for $local_part${local_part_suffix}@$domain"
  driver = redirect
  check_ancestor
  check_local_user
  directory_transport = address_directory
  domains = +local_domains
  # filter - I have disabled filtering to force users to use .forward-foo files
  # or procmail. This will make it easier to move mailers in the future
  #
  # This bit does the qmailesque extension names, foo-bar@ is .forward-foo it
  # also checks if the .forward-bar exists, if not then it uses
  # .forward-default instead.
  file = $home/.forward\
         ${if eq{}{$local_part_suffix}{}{\
	   ${if exists {${home}/.forward${local_part_suffix}} \
	     {${local_part_suffix}}{-default}}\
	   }\
	  }
  file_transport = address_file
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  local_part_suffix = -*
  local_part_suffix_optional
  modemask = 002
  pipe_transport = address_pipe
  reply_transport = address_reply
  require_files = $home
  no_verify

# This delivers to procmail
procmail:
  debug_print = "R: procmail for $local_part@$domain"
  driver = accept
  check_local_user
  domains = +local_domains
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  local_part_suffix = -*
  local_part_suffix_optional
  no_verify
  no_expn
  require_files = $local_part:$home/.procmailrc
  transport = procmail_pipe
  transport_current_directory = $home
  
# This driver delivers to the LDAP generated alias file.
ldap_aliases:
  debug_print = "R: ldap_aliases for $local_part@$domain"
  driver = redirect
  allow_defer
  allow_fail
  data = ${if exists{/var/lib/misc/$primary_hostname/user-forward.cdb}\
             {${lookup{$local_part}cdb\
	       {/var/lib/misc/$primary_hostname/user-forward.cdb}}}}
  domains = +local_domains
  file_transport = address_file
  local_part_suffix = -*
  local_part_suffix_optional
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  pipe_transport = address_pipe
  retry_use_local_part
  
# This director matches local user mailboxes.
localuser:
  debug_print = "R: localuser for $local_part@$domain"
  driver = accept
  check_local_user
  domains = +local_domains
  local_part_suffix = -*
  local_part_suffix_optional
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  # Disable if the user has never logged in
  require_files = $home
  transport = local_delivery
  no_more

# Now we begin the Virtual Domain configuration
# Everything before here should apply only to the local domains with a 
# domains= rule

<%- if @is_packagesmaster -%>
# This router delivers for packages.d.o
packages:
  debug_print = "R: packages for $local_part@$domain"
  driver = redirect
  file_transport = address_file
  pipe_transport = address_pipe
  domains = packages.debian.org
  require_files = /srv/packages.debian.org/conf/maintainer
  data = ${lookup{$local_part}cdb{/srv/packages.debian.org/conf/maintainer.cdb}}
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  transport_home_directory = /srv/packages.debian.org/mail
  transport_current_directory = /srv/packages.debian.org/mail
  check_ancestor
  retry_use_local_part
  no_more

<%- end -%>
<%- if @is_rtmaster -%>
# This router delivers for rt.d.o
rt_force_new_verbose:
  debug_print = "R: rt for $local_part+new@$domain"
  driver = redirect
  domains = rt.debian.org
  require_files = /usr/bin/rt-mailgate : RT_QUEUE_MAP
  local_parts = ${lookup{${sg{$local_part}{-comment}{}}}lsearch{RT_QUEUE_MAP}{$local_part}{}}
  local_part_suffix = +new
  pipe_transport = rt_pipe
  data = "|/usr/bin/rt-mailgate --queue '${lookup{${sg{$local_part}{-comment}{}}}lsearch{RT_QUEUE_MAP}}' --url https://rt.debian.org/ --action ${if match{$local_part}{.*-comment.*}{comment}{correspond}}"
  headers_remove = Subject
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}\nSubject: ${if and {{first_delivery}{match {$h_subject:}{(?i)(.*?)\\\\[?debian rt\\\\]?[:\\s]*(.*)}}} {$1$2}{$h_subject:}}"

# FIXME: figure out how to generalize this approach so that all of the following would work
# - rt+NNNN@rt.debian.org          : attach correspondence to ticket (verbose)
# - rt+NNNN-quiesce@rt.debian.org  : attach correspondence to ticket (quiesce)
# - rt+NNNN-<action>@rt.debian.org : attach correspondence to ticket (some action)
# requires modification to custom condition in 'scrips'
rt_force_new_quiesce:
  debug_print = "R: rt for $local_part+new-quiesce@$domain"
  driver = redirect
  domains = rt.debian.org
  require_files = /usr/bin/rt-mailgate : RT_QUEUE_MAP
  local_parts = ${lookup{${sg{$local_part}{-comment}{}}}lsearch{RT_QUEUE_MAP}{$local_part}{}}
  local_part_suffix = +new-quiesce
  pipe_transport = rt_pipe
  data = "|/usr/bin/rt-mailgate --queue '${lookup{${sg{$local_part}{-comment}{}}}lsearch{RT_QUEUE_MAP}}' --url https://rt.debian.org/ --action ${if match{$local_part}{.*-comment.*}{comment}{correspond}}"
  headers_remove = Subject
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}\nX-RT-Mode: quiesce\nSubject: ${if and {{first_delivery}{match {$h_subject:}{(?i)(.*?)\\\\[?debian rt\\\\]?[:\\s]*(.*)}}} {$1$2}{$h_subject:}}"

rt_otherwise:
  debug_print = "R: rt for $local_part@$domain"
  driver = redirect
  domains = rt.debian.org
  require_files = /usr/bin/rt-mailgate : RT_QUEUE_MAP
  local_parts = ${lookup{${sg{$local_part}{-(comment|done)}{}}}lsearch{RT_QUEUE_MAP}{$local_part}{}}
  local_part_suffix = +*
  local_part_suffix_optional
  pipe_transport = rt_pipe
  data = "|/usr/bin/rt-mailgate --queue '${lookup{${sg{$local_part}{-(comment|done)}{}}}lsearch{RT_QUEUE_MAP}}' --url https://rt.debian.org/ --extension ticket --action ${if match{$local_part}{.*-comment.*}{comment}{${if match{$local_part}{.*-done.*}{correspond-resolve}{correspond}}}}"
  headers_remove = Subject
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}\nSubject: ${if and {{first_delivery}{match {$h_subject:}{(?i)(.*?)\\\\[?debian rt\\\\]?[:\\s]*(.*)}}} {$1$2}{$h_subject:}}"
<%- end -%>

# exim4 fails the router if it can't change to the user/group for delivery
# during verification.  So we have to seperate the cases of verifying
# the virts, and delivering to them.  blah.

virt_direct_verify:
  debug_print = "R: virt_direct for $local_part@$domain"
  driver = redirect
  no_check_local_user
  user = Debian-exim
  allow_filter
  modemask = 002
  directory_transport = address_directory
  domains = +virtual_domains
  local_part_suffix = -*
  local_part_suffix_optional
  file = $home/.forward-\
              ${if exists {${home}/.forward-${local_part}}{${local_part}}\
	           {default}}
  file_transport = address_file
  pipe_transport = address_pipe
  reply_transport = address_reply
  retry_use_local_part
  router_home_directory = ${extract{directory}{VDOMAINDATA}}
  transport_current_directory = ${extract{directory}{VDOMAINDATA}}
  verify_only

# This is a qmailesque deliver into a directory of .forward files
virt_direct:
  debug_print = "R: virt_direct for $local_part@$domain"
  driver = redirect
  allow_filter
  allow_fail
  allow_defer
  no_check_local_user
  directory_transport = address_directory
  domains = +virtual_domains
  file = $home/.forward-\
              ${if exists {${home}/.forward-${local_part}}{${local_part}}\
	           {default}}
  file_transport = ${if eq {${extract{group_writable}{VDOMAINDATA}}}{true}{address_file_group}{address_file}}
  group = ${extract{group}{VDOMAINDATA}}
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  modemask = 002
  local_part_suffix = -*
  local_part_suffix_optional
  pipe_transport = address_pipe
  reply_transport = address_reply
  retry_use_local_part
  router_home_directory = ${extract{directory}{VDOMAINDATA}}
  transport_current_directory = ${extract{directory}{VDOMAINDATA}}
  no_verify
  user = ${extract{user}{VDOMAINDATA}}
  #debug_print = .forward-${if exists {${home}/.forward-${local_part}} {${local_part}} {default}}

# This router delivers to the LDAP generated mail-forward file.
# It's only really useful for debian.org
virt_users:
  debug_print = "R: virt_users for $local_part@$domain"
  driver = redirect
  allow_defer
  allow_fail
  router_home_directory = ${extract{directory}{VDOMAINDATA}}
  transport_current_directory = ${extract{directory}{VDOMAINDATA}}
  user = ${extract{user}{VDOMAINDATA}}
  group = ${extract{group}{VDOMAINDATA}}
  # Manually construct the forwarding address, preserving the
  # local_part_suffix if the remote host is master.
  data = ${if and {{exists{${extract{directory}{VDOMAINDATA}{${value}/mail-forward.cdb}}}}\
                     {! eq {${lookup{$local_part}cdb\
                            {${extract{directory}{VDOMAINDATA}{${value}/mail-forward.cdb}}}}}\
                           {}}}\
             {${local_part:${lookup{$local_part}cdb\
             {${extract{directory}{VDOMAINDATA}{${value}/mail-forward.cdb}}}}}\
             ${if eq {${domain:${lookup{$local_part}cdb\
             {${extract{directory}{VDOMAINDATA}{${value}/mail-forward.cdb}}}}}}{master.debian.org}{$local_part_suffix} {}}\
             @\
             ${domain:${lookup{$local_part}cdb\
            {${extract{directory}{VDOMAINDATA}{${value}/mail-forward.cdb}}}}}}}
  domains = +virtual_domains
  file_transport = address_file
  headers_add = "Delivered-To: ${local_part}${local_part_suffix}@${domain}"
  pipe_transport = address_pipe
  local_part_suffix = -*
  local_part_suffix_optional
  retry_use_local_part

<%=
out = ""
if @is_bugsmaster or @is_bugsmx
  domain = 'bugs.debian.org'
  if @is_bugsmaster
    domain = 'bugs-master.debian.org'
  end
  out = '
# This router delivers for bugs.d.o
bugs:
  debug_print = "R: bugs for $local_part@$domain"
  driver = accept
  transport = bugs_pipe
  domains = ' + domain + '
  cannot_route_message = Unknown or archived bug
  require_files = /org/bugs.debian.org/mail/run-procmail
  no_more
  local_parts = ${if match\
                  {$local_part}\
                  {\N^(\d+)(\d{2})(?:-(?:(?:submit|maintonly|quiet|forwarded|done|close|request|submitter)|(?:unsubscribe|ignore|help|(?:sub(?:scribe|help|yes|approve|reject))|unsubyes|bounce|probe|approve|reject|setlistyes|setlistsilentyes).*))?$\N}\
               {${if exists{/org/bugs.debian.org/spool/db-h/$2/$1$2.summary}\
	       {$local_part}fail}}fail}
'
end
out
%>
######################################################################
#                      TRANSPORTS CONFIGURATION                      #
######################################################################
#                       ORDER DOES NOT MATTER                        #
#     Only one appropriate transport is called for each delivery.    #
######################################################################


begin transports

# This transport is used for local delivery to user mailboxes. On debian
# systems group mail is used so we can write to the /var/mail
# directory. (The alternative, which most other unixes use, is to deliver
# as the user's own group, into a sticky-bitted directory)
local_delivery:
  driver = appendfile
  file = /var/mail/${local_part}
  group = mail
  mode = 0660
  no_mode_fail_narrower
  return_path_add
  
# This transport is used for handling pipe addresses generated by alias
# or .forward files. It has a conventional name, since it is not actually
# mentioned elsewhere in this configuration file. (A different name *can*
# be specified via the "address_pipe_transport" option if you really want
# to.) If the pipe generates any standard output, it is returned to the sender
# of the message as a delivery error. Set return_fail_output instead if you
# want this to happen only when the pipe fails to complete normally.

address_pipe:
  driver = pipe
  current_directory = ${home}
  environment = "EXTENSION=${substr_1:${local_part_suffix}}:\
                 EXT=${substr_1:${local_part_suffix}}:\
                 LOCAL=${local_part}${local_part_suffix}:\
                 RECIPIENT=${local_part}${local_part_suffix}@${domain}"
  return_output
  return_path_add

# This transport is used for handling file addresses generated by alias
# or .forward files. It has a conventional name, since it is not actually
# mentioned elsewhere in this configuration file.

address_file:
  driver = appendfile
  return_path_add

address_file_group:
  driver = appendfile
  return_path_add
  mode = 0660
  directory_mode = 0770
  mode_fail_narrower = false

# This transport is used for handling file addresses generated by alias
# or .forward files if the path ends in "/", which causes it to be treated
# as a directory name rather than a file name. Each message is then delivered
# to a unique file in the directory. If instead you want all such deliveries to
# be in the "maildir" format that is used by some other mail software,
# uncomment the final option below. If this is done, the directory specified
# in the .forward or alias file is the base maildir directory.
#
# Should you want to be able to specify either maildir or non-maildir
# directory-style deliveries, then you must set up yet another transport,
# called address_directory2. This is used if the path ends in "//" so should
# be the one used for maildir, as the double slash suggests another level
# of directory. In the absence of address_directory2, paths ending in //
# are passed to address_directory.

address_directory:
  driver = appendfile
  check_string = 
  maildir_format
  message_prefix = ""
  message_suffix = ""
  return_path_add

# This transport is used for handling autoreplies generated by the filtering
# option of the forwardfile director. It has a conventional name, since it
# is not actually mentioned elsewhere in this configuration file.
address_reply:
  driver = autoreply

# This transport is used for delivering messages over SMTP connections.

remote_smtp:
  driver = smtp
  connect_timeout = 15s
  delay_after_cutoff = false
  tls_certificate = /etc/exim4/ssl/thishost.crt
  tls_privatekey = /etc/exim4/ssl/thishost.key

<%=
out = ""
if not scope.lookupvar('site::nodeinfo')['smarthost'].empty?
out = '
remote_smtp_smarthost:
  debug_print = "T: remote_smtp_smarthost for $local_part@$domain"
  driver = smtp
  delay_after_cutoff = false
  port = '
  out += scope.lookupvar('site::nodeinfo')['smarthost_port'].to_s + "\n"
  out += '  tls_tempfail_tryclear = false
  hosts_require_tls = ' + scope.lookupvar('site::nodeinfo')['smarthost'] + '
  tls_certificate = /etc/exim4/ssl/thishost.crt
  tls_privatekey = /etc/exim4/ssl/thishost.key
'
end
out
%>
# Send the message to procmail
procmail_pipe:
  driver = pipe
  command = /usr/bin/procmail -a ${substr_1:${local_part_suffix}}
  return_path_add
  user = ${local_part}

bsmtp:
  driver = appendfile
  batch_max = 100
  file = ${host}
  message_prefix = 
  message_suffix = 
  use_bsmtp
  user = ${extract{user}{\
                   ${lookup{$domain}partial-lsearch{/etc/exim4/bsmtp}\
		     {$value}fail}\
		   }}

<%- if @is_bugsmaster or @is_bugsmx -%>
bugs_pipe:
  driver = pipe
  command = /org/bugs.debian.org/mail/run-procmail
  environment = "EXTENSION=${substr_1:${local_part_suffix}}:\
                 EXT=${substr_1:${local_part_suffix}}:\
                 LOCAL=${local_part}${local_part_suffix}:\
                 RECIPIENT=${local_part}${local_part_suffix}@${domain}"
  return_path_add
  return_output
  user = debbugs

<%- end -%>
<%- if @is_rtmaster -%>
rt_pipe:
  debug_print = "T: rt_pipe for $local_part${local_part_suffix}@$domain"
  driver = pipe
  return_fail_output
  environment = EXTENSION=${substr_1:${local_part_suffix}}
  allow_commands = /usr/bin/rt-mailgate

<%- end -%>

######################################################################
#                      RETRY CONFIGURATION                           #
######################################################################

# This single retry rule applies to all domains and all errors. It specifies
# retries every 15 minutes for 2 hours, then increasing retry intervals,
# starting at 2 hours and increasing each time by a factor of 1.5, up to 16
# hours, then retries every 8 hours until 4 days have passed since the first
# failed delivery.

# Domain               Error       Retries
# ------               -----       -------


begin retry

debian.org	       *	   F,2h,10m; G,16h,2h,1.5; F,14d,8h
*                      * senders=: F,2h,10m
*                      rcpt_4xx    F,2h,5m;  F,4h,10m; F,4d,15m
*                      *           F,2h,15m; G,16h,2h,1.5; F,4d,8h

# End of Exim 4 configuration
